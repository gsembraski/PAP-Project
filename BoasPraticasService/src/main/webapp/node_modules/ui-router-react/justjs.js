"use strict";
/**
 * Naive, pure JS implementation of core ui-router services
 *
 * @module justjs
 */ /** */
var ui_router_core_1 = require("ui-router-core");
var ui_router_core_2 = require("ui-router-core");
var ui_router_core_3 = require("ui-router-core");
/** $q-like promise api */
ui_router_core_1.services.$q = {
    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },
    defer: function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    },
    all: function (promises) {
        if (ui_router_core_2.isArray(promises)) {
            return new Promise(function (resolve, reject) {
                var results = [];
                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, ui_router_core_1.services.$q.when())
                    .then(function () { resolve(results); }, reject);
            });
        }
        if (ui_router_core_2.isObject(promises)) {
            // console.log("$q.all({}) Input:", promises);
            // Convert promises map to promises array.
            // When each promise resolves, map it to a tuple { key: key, val: val }
            var chain = Object.keys(promises)
                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
            // Then wait for all promises to resolve, and convert them back to an object
            return ui_router_core_1.services.$q.all(chain).then(function (values) {
                var value = values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});
                // console.log("$q.all({}) Output:", value);
                return value;
            });
        }
    }
};
/** angular1-like injector api */
// globally available injectables
var globals = {};
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
ui_router_core_1.services.$injector = {
    get: function (name) { return globals[name]; },
    has: function (name) { return ui_router_core_1.services.$injector.get(name) != null; },
    invoke: function (fn, context, locals) {
        var all = ui_router_core_3.extend({}, globals, locals || {});
        var params = ui_router_core_1.services.$injector.annotate(fn);
        var ensureExist = ui_router_core_3.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return ("DI can't find injectable: '" + key + "'"); });
        var args = params.filter(ensureExist).map(function (x) { return all[x]; });
        if (ui_router_core_2.isFunction(fn))
            return fn.apply(context, args);
        else
            return fn.slice(-1)[0].apply(context, args);
    },
    annotate: function (fn) {
        if (!ui_router_core_2.isInjectable(fn))
            throw new Error("Not an injectable function: " + fn);
        if (fn && fn.$inject)
            return fn.$inject;
        if (ui_router_core_2.isArray(fn))
            return fn.slice(0, -1);
        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        return result || [];
    }
};
/** angular1-like location provider */
var loc = ui_router_core_1.services.location;
var hashPrefix = '';
var baseHref = "";
var locCfg = ui_router_core_1.services.locationConfig;
locCfg.port = function () { return location.port; };
locCfg.protocol = function () { return location.protocol; };
locCfg.host = function () { return location.host; };
locCfg.baseHref = function (newBaseHref) {
    if (ui_router_core_2.isDefined(newBaseHref)) {
        baseHref = newBaseHref;
    }
    return baseHref;
};
locCfg.html5Mode = function () { return false; };
locCfg.hashPrefix = function (newprefix) {
    if (ui_router_core_2.isDefined(newprefix)) {
        hashPrefix = newprefix;
    }
    return hashPrefix;
};
var beforeAfterSubstr = function (char) { return function (str) {
    if (!str)
        return ["", ""];
    var idx = str.indexOf(char);
    if (idx === -1)
        return [str, ""];
    return [str.substr(0, idx), str.substr(idx + 1)];
}; };
var splitHash = beforeAfterSubstr("#");
var splitQuery = beforeAfterSubstr("?");
var splitEqual = beforeAfterSubstr("=");
var trimHashVal = function (str) { return str ? str.replace(/^#/, "") : ""; };
var keyValsToObjectR = function (accum, _a) {
    var key = _a[0], val = _a[1];
    if (!accum.hasOwnProperty(key)) {
        accum[key] = val;
    }
    else if (ui_router_core_2.isArray(accum[key])) {
        accum[key].push(val);
    }
    else {
        accum[key] = [accum[key], val];
    }
    return accum;
};
var getParams = function (queryString) { return queryString.split("&").map(splitEqual).reduce(keyValsToObjectR, {}); };
// Location: hash mode or pushstate mode
exports.hashLocation = {
    hash: function () {
        return splitHash(trimHashVal(location.hash))[1];
    },
    path: function () {
        return splitHash(splitQuery(trimHashVal(location.hash))[0])[0];
    },
    search: function () {
        return getParams(splitQuery(splitHash(trimHashVal(location.hash))[1])[1]);
    },
    setUrl: function (url, replace) {
        if (replace === void 0) { replace = true; }
        if (url)
            location.hash = url;
    },
    url: function (url) {
        return loc.path();
    },
    onChange: function (cb) { return window.addEventListener("hashchange", cb, false); }
};
exports.pushStateLocation = {
    hash: function () {
        return trimHashVal(location.hash);
    },
    path: function () {
        var base = locCfg.baseHref();
        var path = location.pathname;
        var idx = path.indexOf(base);
        if (idx !== 0)
            throw new Error("current url: " + path + " does not start with <base> tag " + base);
        return path.substr(base.length);
    },
    search: function () {
        return getParams(splitQuery(location.search)[1]);
    },
    setUrl: function (url, replace) {
        if (replace === void 0) { replace = false; }
        if (ui_router_core_2.isDefined(url)) {
            if (replace)
                history.replaceState(null, null, locCfg.baseHref() + url);
            else
                history.pushState(null, null, locCfg.baseHref() + url);
        }
    },
    url: function (url) {
        var hash = loc.hash();
        return loc.path() + (hash ? "#" + hash : "");
    },
    onChange: function (cb) { return window.addEventListener("popstate", cb, false); }
};
Object.assign(loc, exports.hashLocation);
//# sourceMappingURL=justjs.js.map